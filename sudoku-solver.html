<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手機數獨破解器</title>
    <script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Eric-Canas/Homography.js@latest/Homography.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
        #video { width: 100%; max-width: 400px; border: 1px solid #ccc; }
        #capturedPhoto { width: 100%; max-width: 400px; border: 1px solid #ccc; margin: 10px 0; display: none; }
        #canvas { display: none; }
        #annotationCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; display: none; }
        .grid-container { margin: 20px auto; width: 360px; }
        #originalGrid, #solvedGrid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 1px; background: #000; width: 360px; height: 360px; margin: 10px auto; }
        .original-cell, .solved-cell { background: white; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; border: 1px solid #ccc; }
        .original-cell { color: black; }
        .solved-cell { color: green; }
        .thick { border: 3px solid #000 !important; }
        button { padding: 10px 20px; font-size: 16px; margin: 10px; }
        h3 { margin: 10px 0; }
        #annotationContainer { position: relative; display: none; margin: 20px auto; width: 400px; height: 400px; }
        .control-point { fill: red; stroke: yellow; stroke-width: 2px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>手機數獨破解器</h1>
    <p>使用後置相機拍攝數獨題目，捕捉後拖拉四個紅點標註數獨區域，確認後自動校正並辨識。</p>
    
    <video id="video" autoplay playsinline muted></video><br>
    <button id="capture">捕捉畫面</button>
    
    <div id="annotationContainer">
        <img id="capturedPhoto" alt="捕捉的照片">
        <svg id="annotationSvg" width="400" height="400" style="position: absolute; top: 0; left: 0; pointer-events: all;">
            <!-- 四個控制點會動態生成 -->
        </svg>
        <button id="confirmAnnotation">確認標註</button>
    </div>
    
    <canvas id="canvas" width="400" height="400"></canvas>
    <canvas id="warpCanvas" width="400" height="400" style="display: none;"></canvas>
    
    <button id="process" style="display:none;">處理並破解</button>
    
    <h2>辨識結果</h2>
    <div class="grid-container">
        <h3>原題目</h3>
        <div id="originalGrid"></div>
    </div>
    
    <h2>破解結果</h2>
    <div class="grid-container">
        <h3>解決後</h3>
        <div id="solvedGrid"></div>
    </div>
    
    <p id="status"></p>

    <script>
        const video = document.getElementById('video');
        const capturedPhoto = document.getElementById('capturedPhoto');
        const canvas = document.getElementById('canvas');
        const warpCanvas = document.getElementById('warpCanvas');
        const ctx = canvas.getContext('2d');
        const warpCtx = warpCanvas.getContext('2d');
        const originalGridDiv = document.getElementById('originalGrid');
        const solvedGridDiv = document.getElementById('solvedGrid');
        const status = document.getElementById('status');
        const annotationContainer = document.getElementById('annotationContainer');
        const annotationSvg = document.getElementById('annotationSvg');
        let stream = null;
        let capturedImage = null;
        let controlPoints = [
            { x: 50, y: 50 },   // 左上
            { x: 350, y: 50 },  // 右上
            { x: 350, y: 350 }, // 右下
            { x: 50, y: 350 }   // 左下
        ];
        let selectedPoint = -1;
        let isDragging = false;

        // 初始化相機
        navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: 400, height: 400 } 
        }).then(s => {
            stream = s;
            video.srcObject = stream;
        }).catch(err => {
            status.textContent = '無法存取相機：' + err.message;
        });

        // 捕捉畫面
        document.getElementById('capture').addEventListener('click', () => {
            ctx.drawImage(video, 0, 0, 400, 400);
            capturedImage = canvas.toDataURL('image/png');
            
            capturedPhoto.src = capturedImage;
            capturedPhoto.style.display = 'block';
            annotationContainer.style.display = 'block';
            video.style.display = 'none';
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // 初始化控制點
            controlPoints = [
                { x: 50, y: 50 },
                { x: 350, y: 50 },
                { x: 350, y: 350 },
                { x: 50, y: 350 }
            ];
            drawControlPoints();
            status.textContent = '請拖拉紅點標註數獨四角，然後點擊確認。';
        });

        // 拖拉控制點（支援觸控和滑鼠）
        function setupDragging() {
            const events = ['mousedown', 'touchstart'];
            events.forEach(event => annotationSvg.addEventListener(event, onMouseDown));
            const moveEvents = ['mousemove', 'touchmove'];
            moveEvents.forEach(event => document.addEventListener(event, onMouseMove));
            const upEvents = ['mouseup', 'touchend'];
            upEvents.forEach(event => document.addEventListener(event, onMouseUp));
        }

        function onMouseDown(e) {
            e.preventDefault();
            const rect = annotationSvg.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            selectedPoint = controlPoints.findIndex(p => Math.hypot(p.x - x, p.y - y) < 20);
            isDragging = selectedPoint !== -1;
        }

        function onMouseMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            const rect = annotationSvg.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
            const x = Math.max(0, Math.min(400, clientX - rect.left));
            const y = Math.max(0, Math.min(400, clientY - rect.top));
            
            controlPoints[selectedPoint] = { x, y };
            drawControlPoints();
        }

        function onMouseUp(e) {
            isDragging = false;
            selectedPoint = -1;
        }

        // 繪製控制點和四邊形
        function drawControlPoints() {
            annotationSvg.innerHTML = '';
            // 繪製四邊形線條
            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('points', controlPoints.map(p => `${p.x},${p.y}`).join(' '));
            polyline.setAttribute('fill', 'none');
            polyline.setAttribute('stroke', 'blue');
            polyline.setAttribute('stroke-width', '2');
            annotationSvg.appendChild(polyline);
            
            // 繪製四個控制點
            controlPoints.forEach((point, i) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', 10);
                circle.classList.add('control-point');
                annotationSvg.appendChild(circle);
            });
        }

        // 確認標註：應用透視校正
        document.getElementById('confirmAnnotation').addEventListener('click', () => {
            status.textContent = '正在校正透視...';
            const srcPoints = [
                [controlPoints[0].x, controlPoints[0].y],
                [controlPoints[1].x, controlPoints[1].y],
                [controlPoints[2].x, controlPoints[2].y],
                [controlPoints[3].x, controlPoints[3].y]
            ];
            const dstPoints = [[0, 0], [400, 0], [400, 400], [0, 400]];
            
            // 使用 Homography 計算變換
            const homography = Homography.fromPoints(srcPoints, dstPoints);
            homography.transformCanvas(canvas, warpCanvas);
            
            // 隱藏標註介面，顯示處理按鈕
            annotationContainer.style.display = 'none';
            document.getElementById('process').style.display = 'inline';
            status.textContent = '透視校正完成，請點擊處理並破解。';
        });

        // 處理：OCR + 顯示原題目 + 求解
        document.getElementById('process').addEventListener('click', async () => {
            status.textContent = '正在辨識數字...';
            const sudokuGrid = await extractGridFromWarp(); // 使用校正後的 canvas
            if (!sudokuGrid) {
                status.textContent = '辨識失敗，請重新拍攝。';
                return;
            }

            displayOriginalGrid(sudokuGrid);
            status.textContent = '原題目已顯示，正在破解數獨...';

            const gridCopy = sudokuGrid.map(row => [...row]);
            const solved = solveSudoku(gridCopy);
            if (solved) {
                displaySolvedGrid(gridCopy);
                status.textContent = '破解完成！';
            } else {
                status.textContent = '無解或辨識錯誤，請重新載入頁面重新拍攝。';
            }
        });

        // 從校正後 canvas 提取格子
        async function extractGridFromWarp() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            const cellWidth = 400 / 9;
            const cellHeight = 400 / 9;

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = cellWidth;
                    tempCanvas.height = cellHeight;
                    tempCtx.drawImage(warpCanvas, col * cellWidth, row * cellHeight, cellWidth, cellHeight, 0, 0, cellWidth, cellHeight);

                    try {
                        const { data: { text } } = await Tesseract.recognize(tempCanvas, 'eng', {
                            tessedit_char_whitelist: '0123456789',
                            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR
                        });
                        grid[row][col] = parseInt(text.trim()) || 0;
                    } catch (err) {
                        console.error('OCR 錯誤：', err);
                        grid[row][col] = 0;
                    }
                }
            }
            console.log('辨識格子：', grid);
            return grid;
        }

        // 顯示原題目格子
        function displayOriginalGrid(grid) {
            originalGridDiv.innerHTML = '';
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'original-cell';
                    if (((row % 3 === 0) && (col % 3 === 0)) || ((row % 3 === 2) && (col % 3 === 2))) {
                        cell.classList.add('thick');
                    }
                    cell.textContent = grid[row][col] || '';
                    originalGridDiv.appendChild(cell);
                }
            }
        }

        // 顯示解決格子
        function displaySolvedGrid(grid) {
            solvedGridDiv.innerHTML = '';
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'solved-cell';
                    if (((row % 3 === 0) && (col % 3 === 0)) || ((row % 3 === 2) && (col % 3 === 2))) {
                        cell.classList.add('thick');
                    }
                    cell.textContent = grid[row][col] || '';
                    solvedGridDiv.appendChild(cell);
                }
            }
        }

        // 數獨求解器：回溯法
        function solveSudoku(grid) {
            const empty = findEmpty(grid);
            if (!empty) return true;

            const [row, col] = empty;

            for (let num = 1; num <= 9; num++) {
                if (isValid(grid, row, col, num)) {
                    grid[row][col] = num;
                    if (solveSudoku(grid)) return true;
                    grid[row][col] = 0;
                }
            }
            return false;
        }

        function findEmpty(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) return [row, col];
                }
            }
            return null;
        }

        function isValid(grid, row, col, num) {
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num || grid[x][col] === num) return false;
            }
            const startRow = row - row % 3;
            const startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] === num) return false;
                }
            }
            return true;
        }

        // 初始化拖拉
        setupDragging();
    </script>
</body>
</html>