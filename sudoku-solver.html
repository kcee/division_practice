<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手機數獨破解器</title>
    <script src="https://unpkg.com/tesseract.js@v4.1.1/dist/tesseract.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #f0f0f0; }
        #video { width: 100%; max-width: 400px; border: 1px solid #ccc; }
        #capturedPhoto { width: 100%; max-width: 400px; border: 1px solid #ccc; margin: 10px 0; display: none; }
        #canvas { display: none; }
        .grid-container { margin: 20px auto; width: 360px; }
        #originalGrid, #solvedGrid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 1px; background: #000; width: 360px; height: 360px; margin: 10px auto; }
        .original-cell, .solved-cell { background: white; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; border: 1px solid #ccc; }
        .original-cell { color: black; } /* 原題目數字為黑色 */
        .solved-cell { color: green; } /* 解決數字為綠色 */
        .thick { border: 3px solid #000 !important; } /* 粗線分區 */
        button { padding: 10px 20px; font-size: 16px; margin: 10px; }
        h3 { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>手機數獨破解器</h1>
    <p>使用後置相機拍攝數獨題目，點擊「捕捉畫面」來儲存並顯示照片，然後點擊「處理並破解」來辨識、顯示原題目並求解。</p>
    
    <video id="video" autoplay playsinline muted></video><br>
    <button id="capture">捕捉畫面</button>
    <button id="process" style="display:none;">處理並破解</button>
    
    <img id="capturedPhoto" alt="捕捉的照片">
    
    <canvas id="canvas" width="400" height="400"></canvas>
    
    <h2>辨識結果</h2>
    <div class="grid-container">
        <h3>原題目</h3>
        <div id="originalGrid"></div>
    </div>
    
    <h2>破解結果</h2>
    <div class="grid-container">
        <h3>解決後</h3>
        <div id="solvedGrid"></div>
    </div>
    
    <p id="status"></p>

    <script>
        const video = document.getElementById('video');
        const capturedPhoto = document.getElementById('capturedPhoto');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const originalGridDiv = document.getElementById('originalGrid');
        const solvedGridDiv = document.getElementById('solvedGrid');
        const status = document.getElementById('status');
        let stream = null; // 儲存媒體串流以便停止
        let capturedImage = null;

        // 初始化相機（後置鏡頭）
        navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: 400, height: 400 } 
        }).then(s => {
            stream = s;
            video.srcObject = stream;
        }).catch(err => {
            status.textContent = '無法存取相機：' + err.message;
        });

        // 捕捉畫面到 canvas 並顯示照片，停止相機
        document.getElementById('capture').addEventListener('click', () => {
            ctx.drawImage(video, 0, 0, 400, 400);
            capturedImage = canvas.toDataURL('image/png');
            
            // 顯示捕捉的照片
            capturedPhoto.src = capturedImage;
            capturedPhoto.style.display = 'block';
            
            // 隱藏 video
            video.style.display = 'none';
            
            // 停止相機串流
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            document.getElementById('process').style.display = 'inline';
            status.textContent = '畫面已捕捉並顯示，請點擊處理。';
        });

        // 處理：OCR 辨識 + 顯示原題目 + 求解
        document.getElementById('process').addEventListener('click', async () => {
            if (!capturedImage) {
                status.textContent = '請先捕捉畫面。';
                return;
            }
            status.textContent = '正在辨識數字...';
            const sudokuGrid = await extractGrid(); // 提取 9x9 格子數字
            if (!sudokuGrid) {
                status.textContent = '辨識失敗，請重新拍攝。';
                return;
            }

            // 顯示原題目格子
            displayOriginalGrid(sudokuGrid);
            status.textContent = '原題目已顯示，正在破解數獨...';

            // 複製格子以避免修改原版
            const gridCopy = sudokuGrid.map(row => [...row]);
            const solved = solveSudoku(gridCopy);
            if (solved) {
                displaySolvedGrid(gridCopy);
                status.textContent = '破解完成！';
            } else {
                status.textContent = '無解或辨識錯誤，請重新載入頁面重新拍攝。';
            }
        });

        // 提取格子：分割 canvas 成 9x9，使用 Tesseract OCR
        async function extractGrid() {
            const grid = Array(9).fill().map(() => Array(9).fill(0));
            const cellWidth = 400 / 9;
            const cellHeight = 400 / 9;

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    // 擷取單一格子
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = cellWidth;
                    tempCanvas.height = cellHeight;
                    tempCtx.drawImage(canvas, col * cellWidth, row * cellHeight, cellWidth, cellHeight, 0, 0, cellWidth, cellHeight);

                    // OCR 辨識（訓練數字 0-9）
                    try {
                        const { data: { text } } = await Tesseract.recognize(tempCanvas, 'eng', {
                            tessedit_char_whitelist: '0123456789',
                            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR
                        });
                        grid[row][col] = parseInt(text.trim()) || 0;
                    } catch (err) {
                        console.error('OCR 錯誤：', err);
                        grid[row][col] = 0;
                    }
                }
            }
            console.log('辨識格子：', grid); // 除錯用
            return grid;
        }

        // 顯示原題目格子
        function displayOriginalGrid(grid) {
            originalGridDiv.innerHTML = '';
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'original-cell';
                    if (((row % 3 === 0) && (col % 3 === 0)) || ((row % 3 === 2) && (col % 3 === 2))) {
                        cell.classList.add('thick'); // 粗線分區
                    }
                    cell.textContent = grid[row][col] || '';
                    originalGridDiv.appendChild(cell);
                }
            }
        }

        // 顯示解決格子
        function displaySolvedGrid(grid) {
            solvedGridDiv.innerHTML = '';
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'solved-cell';
                    if (((row % 3 === 0) && (col % 3 === 0)) || ((row % 3 === 2) && (col % 3 === 2))) {
                        cell.classList.add('thick'); // 粗線分區
                    }
                    cell.textContent = grid[row][col] || '';
                    solvedGridDiv.appendChild(cell);
                }
            }
        }

        // 數獨求解器：回溯法
        function solveSudoku(grid) {
            const empty = findEmpty(grid);
            if (!empty) return true; // 已解決

            const [row, col] = empty;

            for (let num = 1; num <= 9; num++) {
                if (isValid(grid, row, col, num)) {
                    grid[row][col] = num;

                    if (solveSudoku(grid)) return true;

                    grid[row][col] = 0; // 回溯
                }
            }
            return false;
        }

        function findEmpty(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) return [row, col];
                }
            }
            return null;
        }

        function isValid(grid, row, col, num) {
            // 檢查列、行、3x3 子格
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num || grid[x][col] === num) return false;
            }

            const startRow = row - row % 3;
            const startCol = col - col % 3;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (grid[i + startRow][j + startCol] === num) return false;
                }
            }
            return true;
        }
    </script>
</body>
</html>